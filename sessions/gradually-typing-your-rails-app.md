# Gradually Typing Your Rails App with Sorbet

sponsored by Shopify
Ryan Brushett, Alexandre Masa
[slides](https://github.com/cameron-hicks/RailsConf22/blob/main/sessions/gradually-typing-rails-slides.pdf)

- Sorbet type checking command: `bundle exec srb tc`
- why doesn't shopify use RBS? (type checker)
  - it was introduced later, after they started typing
  - it's a language for type annotations, not a tool; no out-of-the-box experience; isn't valid ruby code, so you have to reimplement a lot of tools such as linting
- **sigil**: a comment at the top of a ruby file that sets the type strictness

  - levels of strictness, from least to most: ignore, false (default), true, strict, strong
  - avoid using `typed: ignore` because it will cause issues not to inclue the file:

    ```ruby
    # foo.rb
    # typed: ignore

    class Foo
      def bar
      end
    end
    ```

    ```ruby
    # bar.rb
    # typed: true
    class Bar < Foo
    end
    ```

    ```sh
    > bundle exec srb tc
    -> error: missing constant Foo
    ```

  - `typed: strong` is buggy and prety much unusable
  - ## at the default level of stricntess, `typed: false`, sorbet will check for:

- two packages of sorbet you can use:
  - `sorbet-static`: add it to the development section of your Gemfile; static type checking at compile time
  - `sorbet-runtime`: add it to the runtime section of your Gemfile; type checks the code while it runs
  - `tapioca`: used to generate ruby interface (rbi) files for gems/dependencies and makes maintaining rbi files much easier
  - [`spoom`](https://github.com/Shopify/spoom): useful for decluttering sorbet's error output, generate coverage reports for how typing is going so far, automation features like bumping files' strictness
    - `bundle exec spoom bump`: checks whether files can be bumped to a higher strictness level without type errors, and if so, bumps them to that level
  - `rubocop-sorbet`: especially helpful for bulk tasks during migration; necessary for maintaining a fast-moving app
  - `sorbet.run`: a nice browser playground. you can open bug reports directly from the playground
- exercise: typing [a fork of the `rubygems.org` repo](https://github.com/Shopify/rubygems.org)
  - fuckton of unresolved constants â€” here's why:
    - sorbet doesn't know about the constants coming from gems
    - any constants that are created only at runtime
    - why not pass the source of the gems to sorbet?
      - they may not be compatible with sorbet
      - would also require passing transitive dependencies
      - so much code would inflate the time it takes to type check
    - alternative: rbi files (ruby interface files) generated by tapioca
      - = a simplified representation of the gem contents (its constants, methods, inheritiance, and mixins)
- what order to go in? what to focus on first?
  - most reused parts of the app:
    - lib
    - helpers
    - methods inside models
  - then, critical parts of the app:
    - complex pierces
    - sources of errors
    - code with a lot of churn
  - run `spoom bump <directory> --force` to force that whole folder up a strictness level. Then run a type check and fix stuff
- type assertions:
  - `T.let`: to declare the type of a variable
  - `T.cast`: to coerce the type of a variable ("trust me, it's right")
  - `T.must`: to remove `T.nilable` from a type
  - `T.bind` to define the type of `self`
  - `T.untyped`: to disable type checking on a variable
  - `T.unsafe`: to disable type checking on a callsite (a variable on which a method is called) without disabling type checking on the variable itself
- **signatures**:

  - enable static & dynamic type checking
  - valid ruby syntax
  - need to extend T::Sig in ruby files to use it (not needed in rbi files)
  - you write it just above the method or accessor
  - it takes a block that defines the return type
    - this block is called a signature builder

  ```ruby
  class MyClass
    extend T::Sig

    sig { void }
    def initialize; end

    sig { returns(T::Boolean) }
    def blank?(item)
      item.nil?
    end
  end
  ```

  - defining param types for the sig:

    ```ruby
    sig do
      params(a: Integer, b: T.nilable(Integer)).void
    end
    def do_nothing(a, b = 2); end
    ```

  - binding self inside a block:
    ```ruby
    sig { params(block: T.proc.bind(Foo).void).void }
    def bar(&block)
      Foo.new.instance_eval(block)
    end
    ```

- configuring sorbet runtime
  - by default, type violations will raise an error in production, which can be disruptive. You want to configure sorbet-runtime to change that behavior.
